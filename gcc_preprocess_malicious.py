import re
import os
import glob
from copy import deepcopy
import pickle
import time


def tokenize():
    """
        tokenize instruction into list of instructions
    """
    token = []
    path = os.path.join("path/test/malicious_w_gcc")
    source_files = glob.glob(f'{path}/**/*.s', recursive=True)
    for file_name in source_files:
        temp_token = []
        with open(file_name, "r", encoding="utf8") as lines:
            for token_lines in lines:
                temp_token.append(token_lines)
        token.append(temp_token)
    return token, source_files

def lables_only(data):
    """
     extract labels only
    """
    temp_list_data = []
    for idx, li in enumerate(data):
        command_line_data = re.search("LFB", li)
        if command_line_data is not None:
            temp_list_data.append(li)
    return temp_list_data


def slice_token(data):
    """
     slice the tokens to add strings of jumps
    """
    idx_flag = None
    for idx, slice_data in enumerate(data):
        command_line_slice_data = re.search('LFE', slice_data)
        command_line_nxt = re.search(":", slice_data)
        if command_line_slice_data is not None:
            idx_flag = idx
        if command_line_nxt is not None and idx_flag is not None:
            if idx_flag < idx:
                del data[idx_flag:idx]
                idx_flag = None
    return data


def remove_bLC(token):
    """
     remove code before LC
    """
    count = 0
    count_1 = 0
    add_list = []
    for list_token in token:
        labels = lables_only(list_token)
        if len(labels) <= 1:
            temp_list = []
            count = 0
            for idx, file_line in enumerate(list_token):
                command_line = re.search("LC0", file_line)
                if command_line is not None and count == 0:
                    count = count+1
                    del list_token[0:idx]
                    for idx, file_line_1 in enumerate(list_token):
                        command_line_LFE = re.search("LFE", file_line_1)
                        if command_line_LFE is not None:
                            del list_token[idx:len(list_token)]
                            add_data = list_token
                else:
                    command_line_LFE = re.search("LFE", file_line)
                    if command_line_LFE is not None:
                        del list_token[idx:len(list_token)]
                        add_data = list_token
        if len(labels) > 1:
            flag = False
            list_token_temp = deepcopy(list_token)
            last_label = labels[len(labels)-1]
            match = re.match(r"([a-z]+)([0-9]+)", last_label, re.I)
            if match:
                items = match.groups()
            join_string = "LFE" + items[1] + ":"
            for idx, file_line_full in enumerate(list_token):
                command_line_full = re.search("LC0", file_line_full)
                command_line_col = re.search(":", file_line_full)
                command_line_EF = re.search(join_string, file_line_full)
                if command_line_full is not None and count == 0:
                    idx_begining = idx
                    count = count + 1
                    flag = True
                if command_line_col is not None and file_line_full != 'LC0:' and flag != True and count_1 == 0:
                    idx_begining = idx
                    count_1 = count_1 + 1
                if command_line_EF is not None:
                    idx_end = idx
                    truncate = list_token[idx_begining:idx_end]
                    slice_func = slice_token(truncate)
                    add_data = slice_func
        add_list.append(add_data)
    return add_list


def remove_bLF(data):
    """
     remove code before LF
    """
    count = 0
    add_list_temp = []
    for i in data:
        remove_LFB_temp = []
        for idx, j in enumerate(i):
            command_line_LFB = re.search("LFB", j)
            if command_line_LFB is not None and count == 0:
                count = count + 1
                del i[0:(idx-1)]
                remove_LFB_temp.append(i)
        add_list_temp.append(i)
    return add_list_temp


def add_bug(remove_BLF, temp_list):
    """
     add strings of jumps to the code
    """
    routine_list = []
    for k, g in zip(remove_BLF, temp_list):
        temp_routine_list = []
        for t in k:
            if len(t.split()) <= 1:
                command_line_colon = re.search(':', t)
                if command_line_colon is not None:
                    temp_routine_list.append(t)
        if len(temp_routine_list) > 2:
            test = add_bug_multi(g, temp_routine_list)
            flat = flatten(test)
            routine_list.append(flat)
        else:
            if len(temp_routine_list) != 0:
                split_temp = temp_routine_list[0].split(":", 1)
                jmp = 'jmp' + " " + split_temp[0]
                g.append(jmp)
                routine_list.append(g)
    return routine_list

def add_bug_multi(data, temp_data):
    """
     add strings of jumps to multiple lable assebmly code
    """
    temp_app = []
    n = 0
    temp_element = ['_main', 'LFB']
    for i in temp_element:
        for j in temp_data:
            search_temp = re.search(i, j)
            if search_temp is not None:
                temp_data.remove(j)
    for a in temp_data:
        for idx, b in enumerate(data):
            command_line_group = re.search(a, b)
            if command_line_group is not None:
                temp_app.append(data[:idx])
                temp_app[n].append("jmp" + " " + temp_data[n])
                n = n+1
                del data[:idx]
    if len(data) != 0:
        data.append("jmp" + " " + temp_element[0])
        temp_app.append(data)
    return temp_app

def flatten(sata):
    return [flat for datum in sata for flat in datum]

def main():
    """
        the assembly code that are converted using gcc complier are made malicious by adding strings of jumps to the code
    """
    start = time.time()
    tokens, sc = tokenize()
    remove_BLC_list = remove_bLC(tokens)
    temp_list = deepcopy(remove_BLC_list)
    remove_BLF_list = remove_bLF(remove_BLC_list)
    add_bugs = add_bug(remove_BLF_list, temp_list)
    time.sleep(1)
    end = time.time()
    pickle_path = "path/pickle_file_train_test" # add list of instruction to pickle file
    pickle_name = os.path.join(pickle_path, 'gcc_malicious_backup')
    file_pickle = os.path.join(pickle_name+'.pkl')
    open_file = open(file_pickle, "wb")
    pickle.dump(add_bugs, open_file)
    open_file.close()


if __name__ == "__main__":
    main()
