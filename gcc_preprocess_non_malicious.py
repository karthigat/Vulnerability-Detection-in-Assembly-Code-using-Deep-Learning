import re
import os
import glob
import pickle
import time

def tokenize(data):
    """
        tokenize all the instructions
    """
    token = []
    temp_token = []
    for token_lines in data:
        temp_token.append(token_lines)
    return temp_token

def lables_only(data):
    """
     extract only the labels from assembly code
    """
    temp_list_data = []
    for idx, li in enumerate(data):
        command_line_data = re.search("LFE", li)
        if command_line_data is not None:
            temp_list_data.append(li)
    return temp_list_data

def single_label(data):
    """
        assembly code that has single lables to extracts
    """
    count = 0
    count_1 = 0
    for idx, token_lines in enumerate(data):
        command_lines_LC = re.search("LC", token_lines)
        command_lines_LF = re.search("LFE", token_lines)
        if command_lines_LC is not None and count == 0:
            del data[0:idx]
            count = count + 1
        if command_lines_LF is not None and count_1 == 0:
            del data[idx:len(data)] 
            count_1 = count_1 + 1
    return data

def multi_label(data_multi):
    """
        assembly code that has multiple labels to extracts
    """

    idx_flag = None
    count = 0
    for idx, token_lines_multi in enumerate(data_multi):
        command_lines_LC = re.search("LC", token_lines_multi)
        command_lines_LE = re.search("LFE", token_lines_multi)
        command_line_colon = re.search(":", token_lines_multi)
        print(token_lines_multi)
        command_line_comma = re.search(",", token_lines_multi)
        if command_line_comma is not None:
            data_multi[idx] = re.sub(",", " ", data_multi[idx])
            print(token_lines_multi)
        if command_lines_LC is not None and count == 0:
            del data_multi[0:idx]
            count = count+1
        if command_lines_LE is not None:
            idx_flag = idx
        if command_line_colon is not None and idx_flag is not None:
            if idx > idx_flag:
                del data_multi[idx_flag:idx]
                idx_flag = None
    return data_multi

def main():
    """
        preprocessing non-malicious dataset that converted using gcc compiler from C code
    """
    stack = []
    path = os.path.join("path/test/non_malicious_w_gcc") # get all assembly code
    source_files = glob.glob(f'{path}/**/*.s', recursive=True)
    start = time.time()
    for file_name in source_files:
        temp_token = []
        with open(file_name, "r", encoding="utf8") as lines:
            token = tokenize(lines)                              
            lables = lables_only(token)
            if len(lables) > 1:
                res = multi_label(token)
            else:
                res = single_label(token)
        stack.append(res)
    time.sleep(1) # time calc
    end = time.time()

    # store the preprocessed assembly code in pickle file
    pickle_path = "path/pickle_file_train_test"
    pickle_name = os.path.join(pickle_path, 'gcc_non_malicious')
    file_pickle = os.path.join(pickle_name+'.pkl')
    open_file = open(file_pickle, "wb")
    pickle.dump(stack, open_file)
    open_file.close()

if __name__ == "__main__":
    main()
