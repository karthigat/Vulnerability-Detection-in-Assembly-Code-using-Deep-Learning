from asyncore import loop
import glob
from os import remove
import re

from numpy import empty
import math
import os
import pickle
import time

def token(file_name):
    """
        -remove the comment line which starts with ';'  
        -make a list for each program by joining all the line by comma
    """
    temp_whole_list = []
   
    for files in file_name:
        add_lines = []
        with open(files, "r", encoding="utf8") as file_lines:
            for lines in file_lines:
                command_lines=re.search(";", lines)
                if command_lines is not None:
                    lines = lines.split(";",1)
                    if len(lines) > 1:
                        lines.remove(lines[1])
                        lines = lines[0]
                lines=re.sub(",", " ", lines)
                rmv =  lines.strip()
                add_lines.append(rmv)
                add_lines = list(filter(None, add_lines))
            temp_whole_list.append(add_lines)
    return temp_whole_list


def removePreStart(data):   
    """
        Remove any line before 1st 'mov' in a code starts
    """
    temp_whole_line = []
    for line in data:  
        count = 0   
        for idx, f_line in enumerate(line):        
            command_lines=re.search("mov", f_line)
            if command_lines is not None and count == 0:
                count = count+1
                del line[0:idx]
                temp_whole_line.append(line)
    return temp_whole_line


def extractRoutine(data):   
    routine_list = []
   
    for index, datum in enumerate(data):
        temp_routine_list = []
        temp_list = []
        for line in datum:
            colon_rmv = re.search(':', line)
            if colon_rmv is not None:
                lines = line.split(":",1)   
                temp_routine_list.append(lines[0])
        if len(temp_routine_list) != 0:
            get_block = block(temp_routine_list, datum)
            routine_list.append(get_block)
       
        else:
            temp_list.append(datum)
            routine_list.append(temp_list)
    return routine_list


def block(data, line):
    reshape_list = []
    temp_data = data[0]
    data.pop(0)
    count = 0
    for index in range(0,len(data)):

        for idx, search_line in enumerate(line):
            command_line = re.search(data[index], search_line)
            if command_line is not None:
                count = count+1
                if count%2 == 0:
                    temp_line=line[0:idx]
                    temp_line.insert(len(line[0:idx]),('jmp'+" "+data[index]))
                    reshape_list.append(temp_line)
                    del line[0:idx]
                else:
                    length = math.ceil(len(line[0:idx])/2)
                    temp_line=line[0:idx]
                    comb = 'jmp'+" "+data[index]
                    temp_line.insert(length,comb)
                    reshape_list.append(temp_line)
                    del line[0:idx]

    line.append('jmp'+" "+temp_data)
    reshape_list.append(line)
    return reshape_list


def flatten(data):
    flat=[]
    for datum in data:
        temp=[]
        if len(datum)>1:
            for i in datum:
                temp=temp+i
            flat.append(temp)
        
        else:
            for i in datum:
                flat.append(i)
    return flat

def getFile():
    path = "path/malicious_wo_gcc"
    source_files = glob.glob(f'{path}/**/*.asm', recursive=True)
    return source_files

def main():
    file_name_pickel = 'bad_dataset_sjump' # path for getting raw assembly file
    file_name = getFile()
    start = time.time()
    tokenize = token(file_name)
    remove_prestart = removePreStart(tokenize)
    extract_routine = extractRoutine(remove_prestart)
    flat = flatten(extract_routine)
    time.sleep(1)
    end = time.time()
    pickle_path = "path/pickle_file/pickle_file_train_test"
    pickle_name = os.path.join(pickle_path, 'malicious_wo_gcc')
    file_pickle = os.path.join(pickle_name+'.pkl')
    open_file = open(file_pickle, "wb")
    pickle.dump(flat, open_file)
    open_file.close()


if __name__ == "__main__":
    main()